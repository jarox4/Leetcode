public class Solution {
    public int[][] Merge(int[][] intervals) 
    {
        return MergeIntervals(intervals: intervals);
    }
    public static int[][] MergeIntervals(int[][] intervals)
        {
            IList<int[]> changeableIntervals = new List<int[]>(intervals);
            for (int firstIntervalIndex = 0; firstIntervalIndex < changeableIntervals.Count(); firstIntervalIndex++)
            {
                for (int secondIntervalIndex = firstIntervalIndex + 1; secondIntervalIndex < changeableIntervals.Count(); secondIntervalIndex++)
                {
                    int[] currentInterval = changeableIntervals[firstIntervalIndex];
                    int[] secondInterval = changeableIntervals[secondIntervalIndex];
                    if (Overlaps(currentInterval, secondInterval))
                    {
                        int firstMin = new int[] { currentInterval[0], secondInterval[0] }.Min();
                        int secondMax = new int[] { currentInterval[1], secondInterval[1] }.Max();
                        changeableIntervals.Add(new int[] { firstMin, secondMax });
                        changeableIntervals.Remove(currentInterval);
                        changeableIntervals.Remove(secondInterval);
                        firstIntervalIndex -= 1;
                        break;

                    }
                }
            }
            int[][] toReturn = new int[changeableIntervals.Count()][];
            changeableIntervals.CopyTo(toReturn, 0);
            return toReturn;
        }
        public static bool Overlaps(int[] interval1, int[] interval2)
        {
            int first1 = interval1[0];
            int first2 = interval1[1];

            int second1 = interval2[0];
            int second2 = interval2[1];
            if (first1 == second1 || first1 == second2 || first2 == second1 || first2 == second2)
                return true;
            if (first1 <= second1 && first2 >= second2)
                return true;
            if (first1 < second1 && first2 > second1 && first2 < second2)
                return true;
            //mirrored
            if (first1 > second1 && first2 < second2)
                return true;
            if (first1 > second1 && second2 > first1 && first2 > second2)
                return true;
            return false;
        }
}
